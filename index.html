<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>DOOM SURVIVORS: INFINITY WAR</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            user-select: none;
            font-family: 'Impact', sans-serif;
        }

        /* UI Î†àÏù¥Ïñ¥ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: #0f0;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            box-shadow: 0 0 8px #0f0;
            z-index: 5;
        }

        #top-hud {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 30px;
            color: #fff;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border: 2px solid #555;
        }

        #xp-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background: #333;
        }

        #xp-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00f, #00ffff);
            transition: width 0.2s;
        }

        #bottom-hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            font-size: 32px;
            text-shadow: 2px 2px 0 #000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #skill-name-display {
            font-size: 20px;
            color: #0ff;
            margin-bottom: 5px;
        }

        #skill-cd {
            width: 200px;
            height: 5px;
            background: #333;
        }

        #skill-bar {
            width: 100%;
            height: 100%;
            background: #0ff;
        }

        #boss-hud {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            display: none;
            flex-direction: column;
            align-items: center;
        }

        #boss-name {
            color: #f00;
            font-size: 24px;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #f00;
        }

        #boss-hp-bar-bg {
            width: 100%;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
        }

        #boss-hp-bar {
            width: 100%;
            height: 100%;
            background: #f00;
            transition: width 0.1s;
        }

        /* Î°úÎπÑ ÌôîÎ©¥ */
        #lobby-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111;
            z-index: 40;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto;
        }

        .lobby-section {
            margin-bottom: 15px;
            width: 90%;
            text-align: center;
        }

        .section-title {
            font-size: 20px;
            color: #aaa;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .selection-grid {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .select-card {
            width: 130px;
            height: 90px;
            background: #222;
            border: 2px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            padding: 5px;
        }

        .select-card:hover {
            background: #333;
            transform: translateY(-2px);
        }

        .select-card.selected {
            border-color: #0f0;
            background: #002200;
            box-shadow: 0 0 10px #0f0;
        }

        .sel-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .sel-name {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }

        .sel-desc {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
            display: none;
        }

        .select-card:hover .sel-desc {
            display: block;
            position: absolute;
            bottom: -25px;
            background: #000;
            padding: 5px;
            z-index: 10;
            border: 1px solid #555;
            width: 150px;
        }

        #lobby-start-btn {
            padding: 15px 80px;
            font-size: 24px;
            background: #00cc00;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Impact';
            margin-top: 20px;
            box-shadow: 0 0 20px #00ff00;
            transition: transform 0.1s;
        }

        #lobby-start-btn:hover {
            background: #00ff00;
            transform: scale(1.05);
        }

        /* Î†àÎ≤®ÏóÖ ÌôîÎ©¥ */
        #levelup-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #levelup-title {
            font-size: 50px;
            color: #ffcc00;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #ffcc00;
        }

        #levelup-guide {
            font-size: 20px;
            color: #fff;
            margin-bottom: 30px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }

        #cards-container {
            display: flex;
            gap: 30px;
        }

        .upgrade-card {
            position: relative;
            width: 220px;
            height: 320px;
            background: #222;
            border: 4px solid #555;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: all 0.1s;
            text-align: center;
            color: #fff;
            cursor: pointer;
        }

        .upgrade-card.selected {
            border-color: #00ff00;
            background: #333;
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }

        /* ÌÅ¥Î¶≠ Î∞©ÏßÄ ÏÉÅÌÉúÏùº Îïå Ïä§ÌÉÄÏùº */
        .upgrade-card.locked {
            filter: grayscale(1);
            cursor: not-allowed;
            border-color: #555;
        }

        .key-hint {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: #fff;
            color: #000;
            font-weight: bold;
            padding: 2px 10px;
            border-radius: 5px;
            font-size: 18px;
        }

        .card-icon {
            font-size: 50px;
            margin-bottom: 20px;
        }

        .card-name {
            font-size: 24px;
            margin-bottom: 10px;
            color: #00ff00;
        }

        .card-desc {
            font-size: 16px;
            color: #ccc;
        }

        /* Í≤∞Í≥º/ÏùºÏãúÏ†ïÏßÄ Î©îÎâ¥ */
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 30;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            pointer-events: auto;
        }

        h1 {
            font-size: 80px;
            color: #f00;
            margin: 0;
            letter-spacing: 10px;
            text-shadow: 0 0 30px #f00;
        }

        p {
            color: #aaa;
            font-size: 20px;
            margin-bottom: 40px;
            text-align: center;
            font-family: 'Courier New';
        }

        button {
            padding: 20px 50px;
            font-size: 24px;
            background: #f00;
            color: #fff;
            border: none;
            cursor: pointer;
            font-family: 'Impact';
            letter-spacing: 2px;
            transition: background 0.3s;
            margin-top: 20px;
        }

        button:hover {
            background: #fff;
            color: #f00;
        }

        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 2;
        }

        #skill-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 20%, rgba(0, 255, 255, 0.4) 100%);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 2;
        }

        #time-freeze-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 255, 0.2);
            mix-blend-mode: screen;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 3;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="damage-overlay"></div>
    <div id="skill-overlay"></div>
    <div id="time-freeze-overlay"></div>

    <div id="ui-layer">
        <div id="xp-container">
            <div id="xp-bar"></div>
        </div>
        <div id="crosshair"></div>
        <div id="top-hud">
            <div class="hud-item">STAGE: <span id="stage-display">1</span></div>
            <div class="hud-item">TIME: <span id="time-display">00:00</span></div>
            <div class="hud-item">LV: <span id="level-display">1</span></div>
            <div class="hud-item" style="color: #f00">KILL: <span id="kill-display">0</span></div>
        </div>
        <div id="boss-hud">
            <div id="boss-name">‚ò†Ô∏è THE OVERLORD ‚ò†Ô∏è</div>
            <div id="boss-hp-bar-bg">
                <div id="boss-hp-bar"></div>
            </div>
        </div>
        <div id="bottom-hud">
            <div id="health-display">HP: 100 / 100</div>
            <div style="font-size: 18px; color: #fff;">
                <div id="skill-name-display">SKILL</div>
                <div id="skill-cd">
                    <div id="skill-bar"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="lobby-screen">
        <h1 style="color:#fff; text-shadow: 0 0 20px #fff; margin-bottom:20px; font-size: 50px;">DOOM SURVIVORS</h1>
        <div class="lobby-section">
            <div class="section-title">SELECT CLASS</div>
            <div class="selection-grid" id="char-grid"></div>
        </div>
        <div class="lobby-section">
            <div class="section-title">SELECT SKILL</div>
            <div class="selection-grid" id="skill-grid"></div>
        </div>
        <button id="lobby-start-btn">START GAME</button>
    </div>

    <div id="levelup-screen">
        <div id="levelup-title">LEVEL UP!</div>
        <div id="levelup-guide">Press [1, 2, 3] to Select -> [ENTER] to Confirm</div>
        <div id="cards-container"></div>
    </div>

    <div id="menu">
        <h1 id="menu-title">PAUSED</h1>
        <p id="menu-desc">PRESS ESC TO RESUME</p>
        <button id="menu-btn">RESUME</button>
    </div>

    <script>
        const CHARACTERS = [
            { id: 'scout', name: 'SCOUT', icon: '‚ö°', desc: 'Fast Speed, Low HP', stats: { hp: 80, speed: 14.0, damage: 1, fireRate: 0.5, jumpForce: 15 } },
            { id: 'heavy', name: 'HEAVY', icon: 'üõ°Ô∏è', desc: 'High HP, Slow', stats: { hp: 200, speed: 8.0, damage: 2, fireRate: 0.8, jumpForce: 12 } },
            { id: 'commando', name: 'COMMANDO', icon: 'üî´', desc: 'Fast Fire', stats: { hp: 120, speed: 10.0, damage: 0.8, fireRate: 0.25, jumpForce: 15 } },
            { id: 'jumper', name: 'JUMPER', icon: 'üöÄ', desc: 'High Jump', stats: { hp: 100, speed: 10.0, damage: 1, fireRate: 0.5, jumpForce: 25 } }
        ];

        const SKILLS = [
            { id: 'heal', name: 'HEAL', icon: '‚ù§Ô∏è', desc: 'Heal 50 HP' },
            { id: 'pulse', name: 'SHOCKWAVE', icon: 'üåä', desc: 'Push Enemies' },
            { id: 'overclock', name: 'OVERCLOCK', icon: 'üî•', desc: 'Rapid Fire (5s)' },
            { id: 'timelock', name: 'TIME LOCK', icon: '‚è±Ô∏è', desc: 'Freeze (5s)' },
            { id: 'warp', name: 'WARP', icon: 'üåÄ', desc: 'Teleport' }
        ];

        const ENEMY_TYPES = {
            BASIC: { color: 0xff0000, hp: 3, damage: 5, speed: 4.0, xp: 20, scale: 1.0, type: 'basic', shape: 'box' },
            RUNNER: { color: 0xffff00, hp: 1, damage: 3, speed: 8.0, xp: 10, scale: 0.7, type: 'runner', shape: 'cone' },
            TANK: { color: 0x0000ff, hp: 15, damage: 10, speed: 2.0, xp: 50, scale: 1.5, type: 'tank', shape: 'dodeca' }
        };

        const GRAVITY = 30.0;
        const TILE_SIZE = 10;
        const WALL_HEIGHT = 6;
        const BOSS_SPAWN_TIME = 180;

        let scene, camera, renderer, clock;
        let elapsedTime = 0;
        let stage = 1;

        let selectedCharIndex = 0;
        let selectedSkillIndex = 1;

        let player = { hp: 100, maxHp: 100, speed: 10.0, damage: 1, fireRate: 0.5, jumpForce: 15, lastShot: 0, level: 1, xp: 0, nextLevelXp: 100, kills: 0, velocity: new THREE.Vector3(), canJump: false, skillReady: true, skillCooldown: 10.0 };
        let keys = { w: false, a: false, s: false, d: false, space: false, shift: false };

        let objects = [];
        let enemies = [];
        let gun, boss;

        let isPlaying = false, isPaused = false, isLevelUpState = false;
        let isGameOver = false;
        let isOverclocked = false, isTimeFrozen = false;

        // ÏûêÎèô Î∞úÏÇ¨ Î∞è ÏûÖÎ†• Ï†úÏñ¥ Î≥ÄÏàò
        let isMouseDown = false;
        let levelUpOpenTime = 0; // Î†àÎ≤®ÏóÖ ÌôîÎ©¥ Îú¨ ÏãúÍ∞Å
        const INPUT_LOCK_DELAY = 500; // 0.5Ï¥à

        let currentUpgrades = [], selectedCardIndex = -1;

        const rawMap = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function init() {
            initLobby();
            clock = new THREE.Clock();
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x050505); scene.fog = new THREE.Fog(0x050505, 0, 50);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.rotation.order = 'YXZ';
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040); scene.add(ambientLight);
            const flashLight = new THREE.SpotLight(0xffffff, 0.8, 60, Math.PI / 4, 0.5, 1); camera.add(flashLight); flashLight.position.set(0, 0, 1); flashLight.target.position.set(0, 0, -1); scene.add(camera);

            const floorGeo = new THREE.PlaneGeometry(2000, 2000); const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }); const floor = new THREE.Mesh(floorGeo, floorMat); floor.rotation.x = -Math.PI / 2; scene.add(floor);

            createGun(); generateMap();

            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown); document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove); window.addEventListener('resize', onWindowResize); document.addEventListener('pointerlockchange', onPointerLockChange);

            document.getElementById('menu-btn').onclick = null;

            animate();
        }

        function initLobby() {
            const charGrid = document.getElementById('char-grid'); const skillGrid = document.getElementById('skill-grid');
            CHARACTERS.forEach((char, idx) => {
                const el = document.createElement('div'); el.className = `select-card ${idx === 0 ? 'selected' : ''}`; el.id = `char-card-${idx}`;
                el.innerHTML = `<div class="sel-icon">${char.icon}</div><div class="sel-name">${char.name}</div><div class="sel-desc">${char.desc}</div>`;
                el.onclick = () => selectLobbyItem('char', idx); charGrid.appendChild(el);
            });
            SKILLS.forEach((skill, idx) => {
                const el = document.createElement('div'); el.className = `select-card ${idx === 1 ? 'selected' : ''}`; el.id = `skill-card-${idx}`;
                el.innerHTML = `<div class="sel-icon">${skill.icon}</div><div class="sel-name">${skill.name}</div><div class="sel-desc">${skill.desc}</div>`;
                el.onclick = () => selectLobbyItem('skill', idx); skillGrid.appendChild(el);
            });
            document.getElementById('lobby-start-btn').onclick = startGame;
        }

        function selectLobbyItem(type, idx) {
            if (type === 'char') {
                selectedCharIndex = idx; document.querySelectorAll('#char-grid .select-card').forEach(c => c.classList.remove('selected')); document.getElementById(`char-card-${idx}`).classList.add('selected');
            } else {
                selectedSkillIndex = idx; document.querySelectorAll('#skill-grid .select-card').forEach(c => c.classList.remove('selected')); document.getElementById(`skill-card-${idx}`).classList.add('selected');
            }
            playSound('ui_select');
        }

        function createGun() { const geo = new THREE.BoxGeometry(0.2, 0.2, 1.0); const mat = new THREE.MeshStandardMaterial({ color: 0x333333 }); gun = new THREE.Mesh(geo, mat); gun.position.set(0.3, -0.4, -0.6); camera.add(gun); }

        function generateMap() {
            const boxGeo = new THREE.BoxGeometry(TILE_SIZE, WALL_HEIGHT * 2, TILE_SIZE); const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
            for (let z = 0; z < rawMap.length; z++) {
                for (let x = 0; x < rawMap[z].length; x++) {
                    if (rawMap[z][x] === 1) { const wall = new THREE.Mesh(boxGeo, wallMat); wall.position.set((x - rawMap[0].length / 2) * TILE_SIZE, WALL_HEIGHT, (z - rawMap.length / 2) * TILE_SIZE); scene.add(wall); objects.push(wall); }
                    else if (rawMap[z][x] === 0 && x === 1 && z === 1) camera.position.set((x - rawMap[0].length / 2) * TILE_SIZE, 2, (z - rawMap.length / 2) * TILE_SIZE);
                }
            }
        }

        function startGame() {
            document.getElementById('lobby-screen').style.display = 'none';
            document.body.requestPointerLock();
            const baseStats = CHARACTERS[selectedCharIndex].stats;
            player = { ...player, ...baseStats, maxHp: baseStats.hp, level: 1, xp: 0, nextLevelXp: 100, kills: 0, skillReady: true };
            stage = 1;
            initStage();
        }

        function initStage() {
            if (SKILLS[selectedSkillIndex].id === 'overclock') player.skillCooldown = 20.0;
            else if (SKILLS[selectedSkillIndex].id === 'timelock') player.skillCooldown = 25.0;
            else if (SKILLS[selectedSkillIndex].id === 'warp') player.skillCooldown = 10.0;
            else player.skillCooldown = 5.0;

            elapsedTime = 0;
            enemies.forEach(e => scene.remove(e)); enemies = [];
            if (boss) { scene.remove(boss); boss = null; }

            let safe = false;
            while (!safe) {
                const rZ = Math.floor(Math.random() * rawMap.length); const rX = Math.floor(Math.random() * rawMap[0].length);
                if (rawMap[rZ][rX] === 0) { camera.position.set((rX - rawMap[0].length / 2) * TILE_SIZE, 2, (rZ - rawMap.length / 2) * TILE_SIZE); safe = true; }
            }

            document.getElementById('boss-hud').style.display = 'none';
            document.getElementById('skill-name-display').innerText = `SKILL: ${SKILLS[selectedSkillIndex].name} (SHIFT)`;

            isPlaying = true; isPaused = false; isLevelUpState = false; isOverclocked = false; isTimeFrozen = false; isGameOver = false;
            isMouseDown = false; // Ï¥àÍ∏∞Ìôî

            updateHUD();
            for (let i = 0; i < 5; i++) spawnEnemy();

            document.getElementById('menu').style.display = 'none';
        }

        function goToLobby() {
            isPlaying = false; isGameOver = false;
            document.exitPointerLock();
            document.getElementById('menu').style.display = 'none';
            document.getElementById('lobby-screen').style.display = 'flex';
        }

        function spawnEnemy() {
            if (boss) return;
            let posX, posZ, safe = false;
            while (!safe) {
                const rZ = Math.floor(Math.random() * rawMap.length); const rX = Math.floor(Math.random() * rawMap[0].length);
                if (rawMap[rZ][rX] === 0) { posX = (rX - rawMap[0].length / 2) * TILE_SIZE; posZ = (rZ - rawMap.length / 2) * TILE_SIZE; if (new THREE.Vector3(posX, 0, posZ).distanceTo(camera.position) > 20) safe = true; }
            }
            let type = ENEMY_TYPES.BASIC;
            const difficulty = Math.min(1.0, elapsedTime / BOSS_SPAWN_TIME);
            const rand = Math.random();
            if (difficulty > 0.5 && rand < 0.2) type = ENEMY_TYPES.TANK; else if (difficulty > 0.2 && rand < 0.4) type = ENEMY_TYPES.RUNNER;

            let geo;
            if (type.shape === 'cone') geo = new THREE.ConeGeometry(1 * type.scale, 4 * type.scale, 8);
            else if (type.shape === 'dodeca') geo = new THREE.DodecahedronGeometry(2 * type.scale, 0);
            else geo = new THREE.BoxGeometry(2 * type.scale, 4 * type.scale, 2 * type.scale);

            const mat = new THREE.MeshStandardMaterial({ color: type.color, emissive: 0x111111 });
            const enemy = new THREE.Mesh(geo, mat);
            enemy.position.set(posX, type.shape === 'dodeca' ? 2 * type.scale : 2 * type.scale, posZ);

            const multiplier = 1 + (stage - 1) * 0.3;
            enemy.userData = { ...type };
            enemy.userData.hp = Math.floor((type.hp + Math.floor(elapsedTime / 30)) * multiplier);
            enemy.userData.damage = Math.floor(type.damage * multiplier);

            scene.add(enemy); enemies.push(enemy);
        }

        function spawnBoss() {
            const geo = new THREE.IcosahedronGeometry(6, 1); const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000, wireframe: true });
            boss = new THREE.Mesh(geo, mat); boss.position.set(0, 8, 0);
            const multiplier = 1 + (stage - 1) * 0.5;
            const hp = Math.floor(500 * multiplier);
            boss.userData = { hp: hp, maxHp: hp, speed: 3.0, type: 'boss', damage: Math.floor(10 * multiplier) };
            scene.add(boss);
            document.getElementById('boss-hud').style.display = 'flex';
            playSound('boss_spawn');
        }

        function useSkill() {
            if (!player.skillReady || isPaused || isLevelUpState) return;
            const skillId = SKILLS[selectedSkillIndex].id;
            if (skillId === 'heal') { player.hp = Math.min(player.hp + 50, player.maxHp); playSound('recharge'); }
            else if (skillId === 'pulse') {
                const targets = boss ? [boss, ...enemies] : enemies;
                targets.forEach(e => {
                    if (e.position.distanceTo(camera.position) < 25) {
                        e.userData.hp -= 10;
                        const dir = new THREE.Vector3().subVectors(e.position, camera.position).normalize(); e.position.addScaledVector(dir, 15);
                        if (e.userData.hp <= 0) killEnemy(e);
                    }
                }); playSkillEffect();
            } else if (skillId === 'overclock') { isOverclocked = true; playSkillEffect(); setTimeout(() => { isOverclocked = false; }, 5000); }
            else if (skillId === 'timelock') { isTimeFrozen = true; document.getElementById('time-freeze-overlay').style.opacity = 1; playSound('skill'); setTimeout(() => { isTimeFrozen = false; document.getElementById('time-freeze-overlay').style.opacity = 0; }, 5000); }
            else if (skillId === 'warp') { warpPlayer(); playSkillEffect(); }

            player.skillReady = false; document.getElementById('skill-bar').style.width = '0%';
            let cd = 0;
            const interval = setInterval(() => { if (isPaused) return; cd += 0.1; const pct = Math.min(100, (cd / player.skillCooldown) * 100); document.getElementById('skill-bar').style.width = pct + '%'; if (cd >= player.skillCooldown) { clearInterval(interval); player.skillReady = true; if (!isLevelUpState) playSound('recharge'); } }, 100);
        }

        function warpPlayer() {
            let safe = false, attempts = 0;
            while (!safe && attempts < 50) {
                const rZ = Math.floor(Math.random() * rawMap.length); const rX = Math.floor(Math.random() * rawMap[0].length);
                if (rawMap[rZ][rX] === 0) { camera.position.set((rX - rawMap[0].length / 2) * TILE_SIZE, 2, (rZ - rawMap.length / 2) * TILE_SIZE); safe = true; } attempts++;
            }
        }

        function playSkillEffect() { playSound('skill'); document.getElementById('skill-overlay').style.opacity = 1; setTimeout(() => document.getElementById('skill-overlay').style.opacity = 0, 500); }

        function shoot() {
            const effectiveFireRate = isOverclocked ? 0.05 : player.fireRate;
            const now = clock.getElapsedTime(); if (now - player.lastShot < effectiveFireRate) return; player.lastShot = now;
            playSound('shoot'); gun.position.z = -0.3; setTimeout(() => gun.position.z = -0.6, 50);
            const raycaster = new THREE.Raycaster(); raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const targets = boss ? [boss, ...enemies] : enemies; const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const hitObj = intersects[0].object; hitObj.userData.hp -= player.damage; createParticles(intersects[0].point, 0xffff00);
                if (hitObj.userData.hp <= 0) killEnemy(hitObj); else { hitObj.material.emissive.setHex(0xffffff); setTimeout(() => hitObj.material.emissive.setHex(0x000000), 100); }
            }
        }

        function killEnemy(obj) {
            if (obj === boss) { winGame(); return; }
            createParticles(obj.position, obj.material.color.getHex()); scene.remove(obj); enemies = enemies.filter(e => e !== obj); player.kills++; gainXp(obj.userData.xp); playSound('kill');
        }
        function createParticles(pos, color) { const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3); const mat = new THREE.MeshBasicMaterial({ color: color }); for (let i = 0; i < 5; i++) { const p = new THREE.Mesh(geo, mat); p.position.copy(pos); p.userData.vel = new THREE.Vector3((Math.random() - 0.5), Math.random(), (Math.random() - 0.5)); scene.add(p); setTimeout(() => scene.remove(p), 300); } }

        function gainXp(amount) { player.xp += amount; if (player.xp >= player.nextLevelXp) { player.level++; player.xp -= player.nextLevelXp; player.nextLevelXp = Math.floor(player.nextLevelXp * 1.2); showLevelUpScreen(); } updateHUD(); }

        function showLevelUpScreen() {
            isLevelUpState = true; isPaused = true; document.exitPointerLock();

            // ÏûÖÎ†• Ïû†Í∏à ÏãúÏûë
            levelUpOpenTime = Date.now();
            isMouseDown = false; // Î∞úÏÇ¨ Î©àÏ∂§

            const screen = document.getElementById('levelup-screen'); const container = document.getElementById('cards-container'); container.innerHTML = ''; screen.style.display = 'flex'; playSound('levelup');
            const upgrades = [{ name: "DAMAGE UP", desc: "Increase Damage", icon: "‚öîÔ∏è", apply: () => player.damage += 1 }, { name: "RAPID FIRE", desc: "Increase Fire Rate", icon: "üî´", apply: () => player.fireRate *= 0.85 }, { name: "SPEED UP", desc: "Move Faster", icon: "‚ö°", apply: () => player.speed += 1.5 }, { name: "MAX HP UP", desc: "Heal & Boost HP", icon: "‚ù§Ô∏è", apply: () => { player.maxHp += 50; player.hp = player.maxHp; } }];
            currentUpgrades = upgrades.sort(() => 0.5 - Math.random()).slice(0, 3); selectedCardIndex = -1;
            currentUpgrades.forEach((upgrade, index) => {
                const card = document.createElement('div'); card.className = 'upgrade-card locked'; card.id = `card-${index}`;
                card.innerHTML = `<div class="key-hint">${index + 1}</div><div class="card-icon">${upgrade.icon}</div><div class="card-name">${upgrade.name}</div><div class="card-desc">${upgrade.desc}</div>`;
                card.onclick = () => {
                    if (Date.now() - levelUpOpenTime < INPUT_LOCK_DELAY) return; // Ïû†Í∏à ÌôïÏù∏
                    selectCard(index); confirmUpgrade();
                };
                container.appendChild(card);
            });

            // Ïû†Í∏à Ìï¥Ï†ú ÌÉÄÏù¥Î®∏ (UI ÏãúÍ∞ÅÏ†Å ÏóÖÎç∞Ïù¥Ìä∏)
            setTimeout(() => {
                document.querySelectorAll('.upgrade-card').forEach(c => c.classList.remove('locked'));
            }, INPUT_LOCK_DELAY);
        }

        function selectCard(index) {
            if (Date.now() - levelUpOpenTime < INPUT_LOCK_DELAY) return; // ÌÇ§Î≥¥Îìú ÏûÖÎ†•ÎèÑ Ïû†Í∏à ÌôïÏù∏
            if (index < 0 || index >= currentUpgrades.length) return;
            selectedCardIndex = index; for (let i = 0; i < 3; i++) document.getElementById(`card-${i}`).classList.remove('selected'); document.getElementById(`card-${index}`).classList.add('selected'); playSound('ui_select');
        }

        function confirmUpgrade() {
            if (selectedCardIndex === -1) return;
            currentUpgrades[selectedCardIndex].apply(); document.getElementById('levelup-screen').style.display = 'none'; isLevelUpState = false; isPaused = false; document.body.requestPointerLock(); updateHUD(); playSound('ui_confirm');
        }

        function updatePlayer(delta) {
            player.velocity.x -= player.velocity.x * 10.0 * delta; player.velocity.z -= player.velocity.z * 10.0 * delta; player.velocity.y -= GRAVITY * delta;
            const direction = new THREE.Vector3(); const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize(); const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion); right.y = 0; right.normalize();
            if (keys.w) direction.add(forward); if (keys.s) direction.sub(forward); if (keys.d) direction.add(right); if (keys.a) direction.sub(right);
            if (direction.lengthSq() > 0) { direction.normalize(); player.velocity.addScaledVector(direction, player.speed * delta * 10); }
            const moveX = player.velocity.x * delta; const nextPos = camera.position.clone(); nextPos.x += moveX; if (!checkCollision(nextPos)) camera.position.x += moveX; else player.velocity.x = 0;
            const moveZ = player.velocity.z * delta; nextPos.copy(camera.position); nextPos.z += moveZ; if (!checkCollision(nextPos)) camera.position.z += moveZ; else player.velocity.z = 0;
            camera.position.y += player.velocity.y * delta; if (camera.position.y < 2) { player.velocity.y = 0; camera.position.y = 2; player.canJump = true; }
            if (keys.space && player.canJump) { player.velocity.y = player.jumpForce; player.canJump = false; }
            if (direction.lengthSq() > 0) { const t = Date.now() * 0.015; gun.position.y = -0.4 + Math.sin(t) * 0.02; gun.position.x = 0.3 + Math.cos(t * 0.5) * 0.02; }
        }
        function checkCollision(newPos) { const playerRadius = 0.5; const wallSize = TILE_SIZE / 2; for (let obj of objects) { const distX = Math.abs(newPos.x - obj.position.x); const distZ = Math.abs(newPos.z - obj.position.z); if (distX < wallSize + playerRadius && distZ < wallSize + playerRadius) return true; } return false; }
        function updateEnemies(delta) {
            if (isTimeFrozen) return;
            const targets = boss ? [boss, ...enemies] : enemies;
            targets.forEach(e => {
                const dist = e.position.distanceTo(camera.position);
                if (e === boss) {
                    const dir = new THREE.Vector3().subVectors(camera.position, e.position).normalize(); e.position.addScaledVector(dir, e.userData.speed * delta);
                    if (dist < 8) takeDamage(e.userData.damage * delta * 2);
                    return;
                }
                e.lookAt(camera.position.x, 2, camera.position.z);
                if (dist > 2.5) {
                    const dir = new THREE.Vector3().subVectors(camera.position, e.position).normalize(); const moveDist = e.userData.speed * delta; const nextPos = e.position.clone().addScaledVector(dir, moveDist);
                    if (!checkCollision(nextPos)) e.position.copy(nextPos); else { let slide = e.position.clone(); slide.x += dir.x * moveDist; if (!checkCollision(slide)) e.position.x += dir.x * moveDist; else { slide = e.position.clone(); slide.z += dir.z * moveDist; if (!checkCollision(slide)) e.position.z += dir.z * moveDist; } }
                } else takeDamage(e.userData.damage * delta);
            });
        }

        function takeDamage(amount) {
            player.hp -= amount;
            document.getElementById('damage-overlay').style.opacity = 1;
            setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 100);
            if (player.hp <= 0) handleGameOver();
        }

        function handleGameOver() {
            isPlaying = false; isGameOver = true; document.exitPointerLock();
            const menu = document.getElementById('menu'); const title = document.getElementById('menu-title'); const btn = document.getElementById('menu-btn'); const desc = document.getElementById('menu-desc');
            menu.style.display = 'flex'; title.innerText = "YOU DIED"; title.style.color = "#f00"; desc.innerText = "RETURN TO LOBBY?"; btn.innerText = "MAIN MENU";
            btn.onclick = goToLobby;
        }

        function winGame() {
            playSound('levelup'); isPlaying = false; isGameOver = true; document.exitPointerLock();
            const menu = document.getElementById('menu'); const title = document.getElementById('menu-title'); const btn = document.getElementById('menu-btn'); const desc = document.getElementById('menu-desc');
            menu.style.display = 'flex'; title.innerText = "STAGE CLEARED"; title.style.color = "#0f0"; desc.innerText = `NEXT STAGE: ${stage + 1} (DIFFICULTY UP)`; btn.innerText = "NEXT STAGE";
            btn.onclick = () => { stage++; document.body.requestPointerLock(); initStage(); };
        }

        function handleMenuClick() {
            const btn = document.getElementById('menu-btn');
            if (btn.innerText === "RESUME") { document.body.requestPointerLock(); }
            else if (btn.innerText === "MAIN MENU") { goToLobby(); }
        }

        function animate() {
            requestAnimationFrame(animate); const delta = clock.getDelta();
            if (isPlaying && !isPaused && !isLevelUpState) {
                elapsedTime += delta;

                // AUTO-FIRE Logic
                if (isMouseDown) shoot();

                if (!boss && elapsedTime > BOSS_SPAWN_TIME) spawnBoss();
                const spawnInterval = Math.max(0.5, 2.0 - (elapsedTime / 300));
                if (Math.random() < (delta / spawnInterval)) spawnEnemy();
                updatePlayer(delta); updateEnemies(delta); updateHUD();
                if (boss && !isTimeFrozen) { boss.rotation.x += delta; boss.rotation.y += delta; }
            }
            renderer.render(scene, camera);
        }

        function updateHUD() {
            const mins = Math.floor(elapsedTime / 60).toString().padStart(2, '0'); const secs = Math.floor(elapsedTime % 60).toString().padStart(2, '0');
            document.getElementById('time-display').innerText = `${mins}:${secs}`;
            document.getElementById('level-display').innerText = player.level;
            document.getElementById('kill-display').innerText = player.kills;
            document.getElementById('stage-display').innerText = stage;
            document.getElementById('xp-bar').style.width = (player.xp / player.nextLevelXp) * 100 + '%';
            document.getElementById('health-display').innerText = `HP: ${Math.floor(player.hp)} / ${player.maxHp}`;
            if (boss) document.getElementById('boss-hp-bar').style.width = (boss.userData.hp / boss.userData.maxHp) * 100 + '%';
        }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function onKeyDown(e) {
            if (isLevelUpState) { if (e.code === 'Digit1') selectCard(0); if (e.code === 'Digit2') selectCard(1); if (e.code === 'Digit3') selectCard(2); if (e.code === 'Enter' || e.code === 'NumpadEnter') confirmUpgrade(); return; }
            switch (e.code) { case 'KeyW': keys.w = true; break; case 'KeyA': keys.a = true; break; case 'KeyS': keys.s = true; break; case 'KeyD': keys.d = true; break; case 'Space': keys.space = true; break; case 'ShiftLeft': useSkill(); break; }
        }
        function onKeyUp(e) { switch (e.code) { case 'KeyW': keys.w = false; break; case 'KeyA': keys.a = false; break; case 'KeyS': keys.s = false; break; case 'KeyD': keys.d = false; break; case 'Space': keys.space = false; break; } }

        // Mouse Input Logic Updated for Auto-Fire & Safety
        function onMouseDown() { if (isPlaying && !isPaused && !isLevelUpState) isMouseDown = true; }
        function onMouseUp() { isMouseDown = false; }

        function onMouseMove(e) { if (document.pointerLockElement === document.body && !isPaused && !isLevelUpState) { camera.rotation.y -= e.movementX * 0.002; camera.rotation.x -= e.movementY * 0.002; camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x)); } }

        function onPointerLockChange() {
            if (document.pointerLockElement === document.body) { isPaused = false; document.getElementById('menu').style.display = 'none'; }
            else {
                if (isPlaying && !isLevelUpState && !isGameOver) {
                    isPaused = true; isMouseDown = false; // Pause stops auto-fire
                    const menu = document.getElementById('menu'); const title = document.getElementById('menu-title'); const btn = document.getElementById('menu-btn'); const desc = document.getElementById('menu-desc');
                    menu.style.display = 'flex'; title.innerText = "PAUSED"; title.style.color = "#fff"; desc.innerText = "PRESS ESC TO RESUME"; btn.innerText = "RESUME"; btn.onclick = () => document.body.requestPointerLock();
                }
            }
        }

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination); const now = audioCtx.currentTime;
            if (type === 'shoot') { osc.type = 'square'; osc.frequency.setValueAtTime(150, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
            else if (type === 'kill') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now + 0.2); }
            else if (type === 'levelup') { osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.2); gain.gain.setValueAtTime(0.2, now); osc.start(now); osc.stop(now + 0.4); }
            else if (type === 'recharge') { osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now + 0.2); }
            else if (type === 'skill') { osc.type = 'triangle'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(300, now + 0.5); gain.gain.setValueAtTime(0.3, now); osc.start(now); osc.stop(now + 0.5); }
            else if (type === 'boss_spawn') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(50, now); gain.gain.setValueAtTime(0.5, now); osc.start(now); osc.stop(now + 2.0); }
            else if (type === 'ui_select') { osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); gain.gain.setValueAtTime(0.05, now); osc.start(now); osc.stop(now + 0.1); }
            else if (type === 'ui_confirm') { osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.1); gain.gain.setValueAtTime(0.05, now); osc.start(now); osc.stop(now + 0.2); }
        }

        init();
    </script>
</body>

</html>